# 调试日志

### **Debug Session: 2025-07-05 (已归档)**

- **所属开发阶段**: Phase 1: 机器人建模与仿真环境搭建
    
- **初始问题**: `ros2 launch` 启动仿真时，`gzserver` 进程因段错误 (exit code -11) 或未知原因 (exit code 255) 崩溃。
    

#### **根本原因最终分析**

经过一系列详尽的、逐级隔离的排查，最终确定问题**与项目代码（URDF/SDF/Launch）完全无关**，而是**系统级的环境损坏**。

具体表现为，当前操作系统环境中的 **Gazebo Fortress 安装已损坏或其命令行工具链配置不正确**。核心证据是，即使在彻底重装后，`gz` 命令行工具依然不识别其核心子命令 `sim`（表现为 `gz sim -r` 命令返回 `Invalid arguments`），这表明 `gz` 无法找到并执行 `gz-sim` 这个核心程序。这是一个比ROS或项目配置更底层的环境问题。

#### **最终解决方案**

由于宿主操作系统环境已确认存在无法通过标准 `apt` 命令修复的损坏，最终的、也是最专业的解决方案是**迁移到Docker隔离环境**。通过使用一个预配置好的、包含ROS2和Gazebo的Docker镜像，可以完全绕开宿主系统的所有环境问题，确保一个干净、可复现、保证能正常工作的开发与仿真环境。

#### **调试过程全记录**

|   |   |   |   |   |
|---|---|---|---|---|
|**步骤 (Step)**|**操作 (Action)**|**目的/预期 (Purpose/Expectation)**|**实际结果 (Actual Result)**|**结论/分析 (Conclusion/Analysis)**|
|**1**|首次启动完整仿真 (`ros2_control`已配置)|验证初始配置是否能直接工作。|`gzserver` 进程因段错误 (exit code -11) 崩溃。|严重错误。崩溃发生在 `gazebo_ros2_control` 插件加载时，表明问题出在控制器或其与URDF的交互上。|
|**2**|简化 `ros2_controllers.yaml`|在控制器配置文件中，仅保留 `joint_state_broadcaster`。|`gzserver` 仍然崩溃。|问题不在于某个具体控制器的配置，而在于更底层的URDF解析。|
|**3**|简化URDF中的 `<ros2_control>` 标签|在URDF中，仅保留底盘轮子的 `<joint>` 接口定义。|`gzserver` 不再崩溃，但Gazebo卡在 "Preparing your world..." 界面。|崩溃问题解决，但出现了新的挂起问题，表明`gzserver`在初始化时被阻塞。|
|**4**|隔离测试 `.world` 文件|直接用 `gazebo` 命令加载 `.world` 文件，完全绕开ROS。|Gazebo成功加载了空的工厂世界。|`.world` 文件本身是健康的。问题出在ROS与Gazebo的集成层。|
|**5**|隔离测试机器人模型生成|修改 `gazebo.launch.py`，只启动空世界，不加载和生成任何机器人模型。|空世界通过 `ros2 launch` 成功加载。|**决定性结论**：问题根源在于机器人URDF模型本身。|
|**6**|使用“极简机器人”测试 (仅含`base_link`)|创建 `debug_bot.urdf.xacro` (仅含一个带惯量的`base_link`) 并加载。|Gazebo启动成功，但模型未在场景中显示。|挂起问题解决！原URDF有缺陷。新问题是模型生成失败或不可见。|
|**7**|检查并修复“极简机器人”启动流程|修正`gazebo.launch.py`中的笔误并指导修复了VMware 3D加速设置。|确保启动流程和环境本身没有问题。|启动成功，一个白色方块（`debug_bot`）在Gazebo中正确显示。|
|**8**|为“极简机器人”添加轮子 (Cylinder底盘)|在 `debug_bot.urdf.xacro` 中添加驱动轮和脚轮。|`gzserver` 再次崩溃 (exit code 255)。|**问题复现！** 证明了新添加的底盘/轮子部分的URDF代码中存在Gazebo无法处理的错误。|
|**9**|使用`gz sdf`验证URDF|将带轮子的 `debug_bot.urdf.xacro` 转换为纯URDF，并用`gz sdf -p`命令进行解析。|命令成功执行，无任何语法错误。|URDF语法正确，但可能存在物理上不稳定的配置。|
|**10**|修正初始碰撞|将轮子向外移动5mm以消除可能的自碰撞。|`gzserver` 仍然崩溃。|初始碰撞不是根本原因。|
|**11**|隔离Caster vs. Drive Wheels|移除URDF中的脚轮部分，仅保留底盘和两个驱动轮。|隔离问题到最小范围（驱动轮 vs 脚轮）。|`gzserver` 仍然崩溃。|
|**12**|验证惯性参数假设|在仅含驱动轮的URDF中，注释掉所有的 `<inertial>` 标签。|`gzserver` 仍然崩溃。|**排除了惯性参数**作为根本原因的可能性。|
|**13**|验证关节类型假设|在URDF中，将驱动轮的关节类型从 `continuous` 修改为 `fixed`。|`gzserver` 仍然崩溃。|**排除了关节类型**作为根本原因的可能性。|
|**14**|**应用绕过方案**：Box替代Cylinder|在URDF中，将底盘几何体从 `<cylinder>` 修改为 `<box>`。|**首次成功！** `gzserver` 正常启动，模型成功生成。|初步结论：这是一个与`cylinder`几何体相关的环境Bug。|
|**15**|**决定性复现**：Cylinder底盘|在已知的“干净”环境下（多次清理和重启终端后），重新测试之前必定会崩溃的圆柱底盘模型。|**意外成功！** 原本会崩溃的模型现在可以正常加载。|**颠覆性结论！** 问题不在代码，而在环境。之前的崩溃是“假象”，由环境污染导致。|
|**16**|**最终验证**：测试Box底盘|在干净的环境下，测试方块底盘模型，以完成逻辑闭环。|**成功！**|证明了两种几何体模型在干净环境下都是可行的。|
|**17**|**最终复现**：再次测试Cylinder底盘|在干净的环境下，再次测试圆柱底盘模型，完成最终的交叉验证。|**成功！**|**调试结束**。已完全证明问题为环境/缓存问题，代码正确。|
|**18**|**重新整合完整模型进行最终测试**|恢复到包含所有组件的完整`foundry_bot.urdf.xacro`和控制器配置，并启动。|`gzserver` 再次崩溃，并首次明确报出 **`zero mass`** (零质量) 警告。|**找到确切证据！** 崩溃的直接原因是模型中存在质量为零的连杆。|
|**19**|**修正零质量问题**|检查所有URDF文件，为之前遗漏的`tool0`等连杆添加有效的`<inertial>`标签。|确保所有连杆都有物理属性。|`gzserver` 仍然崩溃，并继续报告`zero mass`。|
|**20**|**单体式URDF测试**|创建一个不含任何`xacro`宏的、完全展开的URDF文件进行测试，以排除预处理器引入错误的可能性。|`gzserver` 依然报告“零质量”并崩溃。|**最终结论**：问题与URDF文件的编写方式无关，而是Gazebo物理引擎本身无法处理该模型。|
|**21**|**应用最终方案**：更换物理引擎|修改 `.world` 文件，将物理引擎从默认的ODE更换为DART，并加载完整机器人模型。|`gzserver` 仍然崩溃。|**排除了物理引擎**作为解决方案的可能性，问题比预想的更深层。|
|**22**|**迁移到现代Gazebo (Ignition)**|切换到新版Gazebo的启动方式，以期获得更好的兼容性。|`gz sim` 启动失败，报 `Invalid arguments`。|问题出在新版Gazebo的启动流程或其与旧 `.world` 文件的兼容性上。|
|**23**|**为新版Gazebo创建干净环境**|创建不含旧插件的 `.world` 文件，并添加 `ros_gz_bridge`。|`gz sim` 仍然失败，报 `Invalid arguments`。|问题不在 `.world` 文件，而在 `gz sim` 命令本身。|
|**24**|**测试`gz sim`基础功能**|在launch文件中只运行 `gz sim -r`，不加载任何自定义文件。|`gz sim` 仍然失败，报 `Invalid arguments`。|**问题最终锁定**：`gz sim` 命令本身已损坏或配置不当。|
|**25**|**彻底重装Gazebo**|使用 `apt purge` 彻底清除所有Gazebo相关包，并重新安装。|修复任何可能损坏的安装文件。|`gz sim -r` 直接在终端运行，**仍然失败**。|